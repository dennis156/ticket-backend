var util = require('util');
var verify = require('wizzi-core').verify;
var lineparser = require('wizzi-core').lineparser;
var jstparser = require('./jsonStatementTree');

var myname = 'js.module.common';
var md = module.exports = {};

md.load_vars = function (me) {

    me.stm.var = function (model, ctx) {
        if (model.statements && model.statements.length > 0) {
            ctx.__inside_expr = true;
            ctx.write('var ');
            if (model.WmtName && model.WmtName.length > 0) ctx.write(model.WmtName + ' = ');
            var indented, item = model.statements[0];
            me.genLoop(item, ctx);
            for (var i = 1; i < model.statements.length; i++) {
                if (ctx.__needs_comma) { ctx.write(','); ctx.__needs_comma = false; }
                if (ctx.__needs_crlf) { ctx.w(); ctx.__needs_crlf = false; }
                if (i == 1) { ctx.indent(); indented = true }
                item = model.statements[i];
                me.genLoop(item, ctx);
            }
            ctx.w(';');
            if (indented) ctx.deindent();
            ctx.__needs_crlf = ctx.__needs_comma = ctx.__inside_expr = false;
        } else {
            ctx.w('var ' + model.WmtName + semicolon(model.WmtName));
        }
    }
    me.stm.decl = function (model, ctx) {
        ctx.write(model.WmtName);
        if (model.statements.length > 0) {
            ctx.write(' = ');
            for (var i = 0; i < model.statements.length; i++) {
                me.genLoop(model.statements[i], ctx);
            }
        }
        ctx.__needs_comma = true;
        ctx.__needs_crlf = true;
    }
    me.stm.new = function (model, ctx) {
        if (model.statements.length > 0) {
            ctx.write('new ');
            var startArg = 0;
            if (model.statements[0].WmtEntity === 'type') {
                ctx.write('(');
                me.genLoop(model.statements[0], ctx);
                ctx.write(')');
                startArg = 1;
            } else {
                ctx.write(model.WmtName);
            }
            var openParen = false;
            for (var i = startArg; i < model.statements.length; i++) {
                var item = model.statements[i];
                if (isMemberAccess(item)) {
                    if (openParen) ctx.write(')');
                    me.genLoop(item, ctx);
                    if (me.isTopStatement(model)) ctx.w(';');
                    return;
                }
                if (i == startArg) {
                    ctx.write('(');
                    openParen = true;
                }
                if (i > startArg) ctx.write(', ');
                me.genLoop(model.statements[i], ctx);
            }
            if (openParen) ctx.write(')');
        } else {
            ctx.write('new ' + model.WmtName);
        }
        if (me.isTopStatement(model)) {
            ctx.w(';');
        }
    }

    me.stm.type = function (model, ctx) {
        model.statements.forEach(function (item) {
            me.genLoop(item, ctx);
        });
    }

}

md.load_calls = function (me) {
    me.stm.call = function (model, ctx) {

        var name = (model.WmtName || '').trim();
        var hasParens = hasArguments(name);

        if (model.statements.length > 0) {
            doCallChildStatements(model, name, hasParens, ctx);
        } else {
            name = hasParens ? name : name + '()';
            ctx.write(name);
            if (me.isTopStatement(model)) ctx.w(semicolon(name));
        }

    }

    me.stm.memberCall = function (model, ctx) {

        var name = (model.WmtName || '').trim();
        var hasParens = hasArguments(name);

        if (model.statements.length > 0) {
            doCallChildStatements(model, '.' + name, hasParens, ctx);
        } else {
            name = hasParens ? '.' + name : '.' + name + '()';
            ctx.write(name);
            if (me.isTopStatement(model)) ctx.w(semicolon(name));
        }

    }

    me.stm.callOnValue = function (model, ctx) {

        hasParens = false;
        if (model.statements.length > 0) {
            doCallChildStatements(model, '', hasParens, ctx);
        } else {
            ctx.write('()');
        }
    }

    function doCallChildStatements(model, name, hasParens, ctx) {

        var childsAreMemberExpr = hasParens;

        ctx.write(name);
        if (childsAreMemberExpr === false) ctx.write('(');

        for (var i = 0; i < model.statements.length; i++) {
            var item = model.statements[i];
            if ((isCallArgument(item) && childsAreMemberExpr) ||
                 isMemberAccess(item)) {
                if (hasParens === false && isMemberAccess(item)) ctx.write(')');
                if (isCallArgument(item)) ctx.write('.');
                me.genLoop(item, ctx);
                for (var j = i + 1; j < model.statements.length; j++) {
                    var item = model.statements[j];
                    if (isCallArgument(item)) ctx.write('.');
                    me.genLoop(item, ctx);
                }
                if (me.isTopStatement(model)) ctx.w(';');
                return;
            }
            if (i > 0) ctx.write(', ');
            me.genLoop(item, ctx);
        };

        if (childsAreMemberExpr === false) ctx.write(')');
        if (me.isTopStatement(model)) ctx.w(';');

    }


    me.stm.memberAccess = function (model, ctx) {
        if (ctx.__inside_html) {
            model.statements.unshift({
                WmtEntity: 'jsPropertyOrValue',
                WmtName: 'class ' + model.WmtName,
                WmtParent: model
            });
            model.WmtEntity = 'div';
            model.WmtName = '';
            me.stm.div(model, ctx);
        } else {
            ctx.write('.' + model.WmtName);
        }
    }

    me.stm.memberAccessComputed = function (model, ctx) {
        if (model.statements && model.statements.length > 0) {
            ctx.write('[');
            var first = true;
            for (var i = 0; i < model.statements.length; i++) {
                var item = model.statements[i];
                if (isMemberAccess(item)) {
                    ctx.write(']');
                    me.genLoop(item, ctx);
                    if (me.isTopStatement(model)) ctx.w(';');
                    return;
                }
                if (!first) ctx.write(', ');
                me.genLoop(item, ctx);
                ctx.first = false;
            }
            ctx.write(']');
        } else {
            ctx.write('[' + model.WmtName + ']');
        }
    }
}

md.load_logic = function (me) {

    me.stm.if = function (model, ctx) {
        emitBlock('if', model, model.statements, model.statements.length, ctx);
    }
    me.stm.test = function (model, ctx) {
        ctx.write('(');
        me.genItems(model.statements, ctx, { indent: false });
        ctx.write(')');
    }
    me.stm.else = function (model, ctx) {
        if (model.WmtParent.WmtEntity === 'iif') {
            if (model.statements.length > 0) {
                me.genItems(model.statements, ctx, { indent: true });
            } else {
                ctx.write(model.WmtName);
            }
        } else {
            emitBlock('else', model, model.statements, model.statements.length, ctx);
        }
    }
    me.stm.elif = function (model, ctx) {
        emitBlock('else if', model, model.statements, model.statements.length, ctx);
    }
    me.stm.switch = function (model, ctx) {
        ctx.w('switch (' + unparen(model.WmtName) + ') {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');
    }

    me.stm.case = function (model, ctx) {
        var items = model.statements,
            count = model.statements.length,
            tag = 'case';
        if (count === 0) {
            ctx.w(tag + ' ' + model.WmtName + ':');
            return;
        }
        if (ctx.values.__preserveBlock) {
            if (count > 0 && items[0].WmtEntity === 'block') {
                ctx.w(tag + ' ' + model.WmtName + ': {');
            }
            else {
                ctx.w(tag + ' ' + model.WmtName + ':');
            }
        }
        else {
            ctx.w(tag + ' ' + model.WmtName + ': {');
        }
        me.genItems(items, ctx, { indent: true });
        if (ctx.values.__preserveBlock) {
            if (count > 0 && items[0].WmtEntity === 'block')
                ctx.w('}');
            else
                ;
        }
        else
            ctx.w('}');
        /*
        ctx.w('case ' + unparen(model.WmtName) + ': {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');
        */
    }
    me.stm.default = function (model, ctx) {
        var items = model.statements,
            count = model.statements.length,
            tag = 'default';
        if (ctx.values.__preserveBlock) {
            if (count > 0 && items[0].WmtEntity === 'block') {
                ctx.w(tag + ': {');
            }
            else {
                ctx.w(tag + ':');
            }
        }
        else {
            ctx.w(tag + ': {');
        }
        me.genItems(items, ctx, { indent: true });
        if (ctx.values.__preserveBlock) {
            if (count > 0 && items[0].WmtEntity === 'block')
                ctx.w('}');
            else
                ;
        }
        else
            ctx.w('}');
        /*
        ctx.w('default: ' + unparen(model.WmtName) + '{');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');
        */
    }

    me.stm.for = function (model, ctx) {
        emitBlock('for', model, model.statements, model.statements.length, ctx);
        /*
        ctx.w('for (' + unparen(model.WmtName) + ') {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');
        */
    }

    me.stm.foreach = function (model, ctx) {
        var ss = model.WmtName.trim().split(' ');
        if (ss.length != 3 || ss[1] !== 'in') {
            throw ctx.error("Malformed foreach. Should be: foreach <item> in <coll>. Is " + model.WmtName, model);
        }
        // console.log('foreach', p.join('§'));
        var item = ss[0],
            coll = ss[2];

        var nidif = ctx.__for_nidif || 0;
        if (nidif >= max_for_nidif) {
            throw ctx.error(myname + '. Maximum number of nested foreach loop is ' + max_for_nidif, model);
        }
        var letter = forloopLetters[nidif];
        var len = letter + '_len';
        ctx.__for_nidif = nidif + 1;

        ctx.w('var ' + letter + ', ' + len + '=' + coll + '.length, ' + item + ';')
        ctx.w('for (' + letter + '=0; ' + letter + '<' + len + '; ' + letter + '++) {')
        ctx.w('    ' + item + ' = ' + coll + '[' + letter + '];')
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');

        ctx.__for_nidif = ctx.__for_nidif - 1;
    }

    me.stm.break = function (model, ctx) {
        ctx.write('break');
        ctx.write((model.WmtName || '').trim().length > 0 ? ' ' + model.WmtName : '');
        ctx.w(';');
    }

    me.stm.continue = function (model, ctx) {
        ctx.write('continue');
        ctx.write((model.WmtName || '').trim().length > 0 ? ' ' + model.WmtName : '');
        ctx.w(';');
    }

    me.stm.while = function (model, ctx) {
        emitBlock('while', model, model.statements, model.statements.length, ctx);
    }

    me.stm.do = function (model, ctx) {
        var items = model.statements;
        var count = model.statements.length;

        ctx.write('do');
        if (ctx.values.__preserveBlock) {
            if (count > 1 ||
                count == 1 && items[0].WmtEntity === 'block') {
                ctx.w(' {');
            } else {
                ctx.w('');
            }
        } else {
            ctx.w(' {');
        }

        me.genItems(model.statements, ctx, { indent: true });

        if (ctx.values.__preserveBlock) {
            if (count > 1 ||
                count == 1 && items[0].WmtEntity === 'block') {
                ctx.write('}');
            }
        } else {
            ctx.write('}');
        }

        ctx.w(' while (' + unparen(model.WmtName) + ')');
    }

    me.stm.label = function (model, ctx) {
        ctx.w(model.WmtName + ':');
        me.genItems(model.statements, ctx, { indent: false });
    }

    me.stm.or = function (model, ctx) {
        me.genLoop(model.statements[0], ctx);
        ctx.write(' || ');
        me.genLoop(model.statements[1], ctx);
    }

    me.stm.and = function (model, ctx) {
        me.genLoop(model.statements[0], ctx);
        ctx.write(' && ');
        me.genLoop(model.statements[1], ctx);
    }

    me.stm.iif = function (model, ctx) {
        var paren = model.statements.length > 2;
        if (paren) ctx.write('(');
        ctx.write(model.WmtName + ' ? ');
        me.genLoop(model.statements[0], ctx);
        ctx.write(' : ');
        me.genLoop(model.statements[1], ctx);
        if (paren) ctx.write(')');
        if (model.statements.length > 2) {
            me.genLoop(model.statements[2], ctx);
        }
        if (me.isTopStatement(model)) {
            ctx.w(';');
        }
    }

    me.stm.then = function (model, ctx) {
        if (model.statements.length > 0) {
            me.genItems(model.statements, ctx, { indent: true });
        } else {
            ctx.write(model.WmtName);
        }
    }

    function emitBlock(tag, model, items, count, ctx) {
        // console.log('ctx.values.__preserveBlock', ctx.values.__preserveBlock, items.length);
        var blockIndex = items.length > 0 && items[0].WmtEntity === 'test' ? 1 : 0;
        if (ctx.values.__preserveBlock) {
            if (count > blockIndex && items[blockIndex].WmtEntity === 'block') {
                if (tag === 'case')
                    ctx.w(tag + ' ' + model.WmtName + ': {');
                else if (tag === 'else')
                    ctx.w(tag + ' {');
                else
                    emitTest(tag, model, items, ctx, ' {');
            } else {
                if (tag === 'case')
                    ctx.w(tag + ' ' + model.WmtName + ':');
                else if (tag === 'else')
                    ctx.w(tag);
                else
                    emitTest(tag, model, items, ctx, '');
            }
        } else {
            if (tag === 'case')
                ctx.w(tag + ' ' + model.WmtName + ': {');
            else if (tag === 'else')
                ctx.w(tag + ' {');
            else
                emitTest(tag, model, items, ctx, ' {');
        }
        if (items.length > 0 && items[0].WmtEntity === 'test')
            me.genItems(items, ctx, { indent: true, from: 1 });
        else
            me.genItems(items, ctx, { indent: true });
        if (ctx.values.__preserveBlock) {
            if (count > blockIndex && items[blockIndex].WmtEntity === 'block') {
                ctx.w('}');
            }
        } else {
            ctx.w('}');
        }
    }

    function emitTest(tag, model, items, ctx, open) {
        if (items.length > 0 && items[0].WmtEntity === 'test') {
            ctx.write(tag + ' ');
            me.genLoop(items[0], ctx);
            ctx.w(open);
        } else {
            ctx.w(tag + ' (' + unparen(model.WmtName) + ')' + open);
        }
    }

}

md.load_struct = function (me) {

    me.stm.jsonStatementTree = function (model, ctx) {
        var statements = jstparser.getStatements(model);
        me.genItems(statements, ctx, { indent: false });
    }
    me.stm.jsPropertyOrValue = function (model, ctx) {
        if (model.statements && model.statements.length > 0) {
            ctx.write(model.WmtName + ': ');
            me.genItems(model.statements, ctx, { indent: false });
        } else {
            if (isParamValue(model) || isValue(model)) {
                ctx.write(model.WmtName);
            } else if (isObjectProperty(model)) {
                var tk, p = lineparser.parse(model.WmtName, model);
                // console.log('lineparse' + model.WmtName, util.inspect(p, { depth: null }));
                if (p.tokens.length >= 2) {
                    tk = p.tokens[0];
                    ctx.write(tk.quote || '');
                    ctx.write(tk.text);
                    ctx.write((tk.quote || '') + ':');
                    for (var i = 1; i < p.tokens.length; i++) {
                        tk = p.tokens[i];
                        if (i === 1) ctx.write(' ');
                        ctx.write(tk.quote || '');
                        ctx.write(tk.raw);
                        ctx.write(tk.quote || '');
                    }
                } else {
                    throw ctx.error(myname + '. Invalid object property: ' + model.WmtName, model);
                }
            } else if (isHtmlAttribute(model)) {
            } else {
                throw ctx.error(myname + '. Invalid jsPropertyOrValue: ' + model.WmtName, model);
            }
        }
    }

    me.stm.jsObject = function (model, ctx) {
        if (model.statements.length == 0) {
            ctx.write('{}');
            // ctx.__needs_crlf = true;
            return;
        }
        ctx.w('{');
        ctx.indent();
        var first = true, comma = true;
        for (var i = 0; i < model.statements.length; i++) {
            var item = model.statements[i];
            if (isMemberAccessOrCall(item)) {
                ctx.w('');
                ctx.deindent();
                ctx.write('}');
                me.genLoop(item, ctx);
                for (var j = i + 1; j < model.statements.length; j++) {
                    var item = model.statements[j];
                    if (isCallArgument(item)) ctx.write('.');
                    me.genLoop(item, ctx);
                }
                return;
            }
            if (comma && !first) ctx.w(', ');
            first = false;
            me.genLoop(item, ctx);
            comma = item.WmtEntity !== 'comment';
        };
        ctx.w('');
        ctx.deindent();
        ctx.write('}');
    }

    me.stm.jsArray = function (model, ctx) {
        if (model.statements.length == 0) {
            ctx.write('[' + (model.WmtName || '') + ']');
            // ctx.__needs_crlf = true;
            return;
        }
        ctx.w('[');
        ctx.indent();
        var first = true;
        for (var i = 0; i < model.statements.length; i++) {
            var item = model.statements[i];
            if (isMemberAccessOrCall(item)) {
                ctx.w('');
                ctx.deindent();
                ctx.write(']');
                me.genLoop(item, ctx);
                for (var j = i + 1; j < model.statements.length; j++) {
                    var item = model.statements[j];
                    if (isCallArgument(item)) ctx.write('.');
                    me.genLoop(item, ctx);
                }
                return;
            }
            if (!first) ctx.w(', ');
            first = false;
            me.genLoop(item, ctx);
        };
        ctx.w('');
        ctx.deindent();
        ctx.write(']');
    }
}

md.load_exceptions = function (me) {
    me.stm.try = function (model, ctx) {
        ctx.w('try {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.write('} ');
    }
    me.stm.catch = function (model, ctx) {
        ctx.w('catch (' + model.WmtName + ') {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');
    }
    me.stm.finally = function (model, ctx) {
        ctx.w('finally {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');
    }
    me.stm.throw = function (model, ctx) {
        if (model.statements && model.statements.length > 0) {
            ctx.write('throw ' + (model.WmtName || ''));
            me.genItems(model.statements, ctx, { indent: true });
            ctx.w(';');
        } else {
            ctx.w('throw ' + model.WmtName + semicolon(model.WmtName));
        }
    }
}

md.load_classes = function (me) {
    me.stm.class = function (model, ctx) {
        var ctor = model.jsctor();
        ctx.write('function ' + model.WmtName + '(');
        if (ctor) {
            var args = (ctor.jsargs() || '');
            if (args.length === 0) {
                var p = lineparser.parse(ctor.WmtName, model);
                if (p.tokens.length > 0) {
                    for (var i = 0; i < p.tokens.length; i++) {
                        var text = p.tokens[i].text;
                        args = args.length > 0 ? args + ', ' + text : text;
                    }
                }
            }
            ctx.write(args);
        }
        ctx.w(') {');

        if (ctor) {
            me.genItems(ctor.statements, ctx, { indent: true });
        }
        ctx.w('}');
        for (var i = 0; i < model.members.length; i++) {
            var item = model.members[i];
            me.genLoop(item, ctx);
        }
    }

    me.stm.ctor = function (model, ctx) {
        // throw new Error("Not implemented");
    }

    me.stm.method = function (model, ctx) {
        var c = getParentOfType(model, 'class');
        var args = (model.jsargs() || ''),
            name = '';
        if (args.length > 0) {
            name = model.WmtName.trim();
        } else {
            var p = lineparser.parse(model.WmtName, model);
            if (p.tokens.length > 0) {
                var state = 0;
                for (var i = 0; i < p.tokens.length; i++) {
                    var text = p.tokens[i].text;
                    if (text === '(') {
                        state = 1;
                    } else if (text === ')') {
                            ;
                    } else if (i == 0 && state == 0) {
                        name = text;
                        state = 1;
                    } else {
                        args = args.length > 0 ? args + ', ' + text : text;
                    }
                }
            }
        }
        if (model.static)
            ctx.write(c.WmtName + '.' + name + ' = function (');
        else
            ctx.write(c.WmtName + '.prototype.' + name + ' = function (');
        ctx.write(args);
        ctx.w(') {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.w('}');
    }

}

md.load_functions = function (me) {

    me.stm.function = function (model, ctx) {
        var args = (model.jsargs() || ''), name = '';
        if (args.length > 0) {
            name = model.WmtName.trim();
        } else {
            var p = lineparser.parse(model.WmtName, model);
            if (p.tokens.length > 0) {
                var state = 0;
                for (var i = 0; i < p.tokens.length; i++) {
                    var text = p.tokens[i].text;
                    if (text === '(') {
                        state = 1;
                    } else if (text === ')') {
                            ;
                    } else if (i == 0 && state == 0) {
                        name = text;
                        state = 1;
                    } else {
                        args = args.length > 0 ? args + ', ' + text : text;
                    }
                }
            }
        }
        var f, iifeInvoke, iife = model.statements.length > 0 && model.statements[model.statements.length - 1].WmtEntity === 'memberCall';
        if (iife) {
            f = '(' + (name.length > 0 ? 'function ' + name : 'function');
            iifeInvoke = model.statements[model.statements.length - 1];
            iifeInvoke.WmtParent = { WmtEntity: 'call' }; // avoid me.isTopStatement
            model.statements.splice(model.statements.length - 1, 1);
        } else {
            f = name.length > 0 ? 'function ' + name : 'function';
        }
        ctx.w(f + '(' + args + ') {');
        me.genItems(model.statements, ctx, { indent: true });
        ctx.write('}');
        if (iife) {
            me.genItems([iifeInvoke], ctx, { indent: false });
            ctx.write(')');
        }
        if (me.isTopStatement(model)) ctx.w('');
    }

    me.stm.iife = function (model, ctx) {
        if (model.unary_prefix) {
            ctx.write(model.unary_prefix);
        }
        ctx.write('(');
        if (model.statements.length != 1 && model.statements[0].WmtEntity !== 'function') {
            var i = 0, test = model.statements[0].WmtEntity;
            while (test === 'comment') {
                i++; test = model.statements[i].WmtEntity;
            }
            if (test !== 'function') throw new Error('First statement of a an iife node must be a function. Instead is ' + model.statements[0].WmtEntity);
        }
        me.genLoop(model.statements[0], ctx);
        ctx.write(')');
        if (model.statements.length === 2 && model.statements[1].WmtEntity === 'memberCall') {
            me.genLoop(model.statements[1], ctx);
        }
        else if ((model.WmtName || '').length > 0) {
            ctx.write(encloseParen(model.WmtName));
        } else {
            ctx.write('(');
            var first = true;
            for (var i = 1; i < model.statements.length; i++) {
                item = model.statements[i];
                // console.log('iife.item.WmtEntity', item.WmtEntity)
                if (item.WmtEntity === 'callOnValue') {
                    ctx.write(')');
                    break;
                }
                if (!first) ctx.write(', ');
                first = false;
                me.genLoop(item, ctx);
            }
            ctx.write(')');
        }
        for (var i = 1; i < model.statements.length; i++) {
            item = model.statements[i];
            if (item.WmtEntity === 'callOnValue') {
                me.genLoop(item, ctx);
            }
        }
        if (me.isTopStatement(model)) ctx.w(';');
    }

    me.stm.return = function (model, ctx) {
        if (model.statements && model.statements.length > 0) {
            ctx.write('return ');
            me.genItems(model.statements, ctx, { indent: true });
            if (model.statements.length == 1) ctx.w(';');
        }
        else
            ctx.w('return ' + (model.WmtName || '') + semicolon(model.WmtName));
    }

}


function getParentOfType(model, type) {
    var prn = model.WmtParent;
    while (prn != null && prn.WmtEntity !== type)
        prn = prn.WmtParent;
    return prn;
}

function isHtmlAttribute(model) {
    // console.log('model.WmtParent.WmtEntity', model.WmtParent.WmtEntity);
    if (!model.WmtParent) return false;
    return ['htmlelement', 'h3', 'form', 'legend', 'div','span','table','thead','tbody','tr','td','th','label','br','input', 'textarea', 'select','option', 'button', 'a','img','i','ul','li'].indexOf(model.WmtParent.WmtEntity) > -1;
}

function isValue(model) {
    // console.log('model.WmtParent.WmtEntity', model.WmtParent.WmtEntity);
    if (!model.WmtParent) return false;
    return ['jsArray', 'jsPropertyOrValue', 'memberAccessComputed', 'or', 'and']
        .indexOf(model.WmtParent.WmtEntity) > -1;
}

function isParamValue(model) {
    // these entities can be passed as param to call ( _ ) and memberCall ( ._ )
    if (!model.WmtParent) return false;
    return ['call', 'memberCall', 'callOnValue', 'iife', 'new']
        .indexOf(model.WmtParent.WmtEntity) > -1;
}

function isObjectProperty(model) {
    // console.log('model.WmtParent.WmtEntity', model.WmtParent.WmtEntity);
    if (!model.WmtParent) return false;
    return ['jsObject'].indexOf(model.WmtParent.WmtEntity) > -1;
}

function isMemberAccess(model) {
    if (['memberAccess', 'memberAccessComputed', 'memberCall', 'callOnValue'].indexOf(model.WmtEntity) > -1) return true;
}

function isMemberAccessOrCall(model) {
    if (['memberAccess', 'memberAccessComputed', 'memberCall', 'callOnValue'].indexOf(model.WmtEntity) > -1) return true;
    if (!model.WmtParent) return false;
    if (model.WmtEntity === 'call' && model.WmtParent.WmtEntity === 'call') return true;
    return false;
}

function isCallArgument(model) {
    return (model.WmtEntity === 'call' && model.WmtParent && model.WmtParent.WmtEntity === 'call');
}

function hasArguments(callText) {
    if (typeof callText !== 'string') return false;
    callText = callText.trim();
    var hasEndParens = callText.substr(-1, 1) === ')' ||
                       callText.substr(-2, 2) === ');';
    if (!hasEndParens) return false;
    var namecount = 0
    var enclosedcount = 0
    var seen = false;
    var count = 0, quote = null;
    for (var ch, i = 0; i < callText.length; i++) {
        ch = callText[i];
        if (ch === '"' || ch === "'") {
            if (quote === ch) quote = null;
            else if (quote === null) quote = ch;
        }
        else if (quote !== null) {
                ;
        }
        else if (ch === '(') {
            seen = true;
            count++;
        } else if (ch === ')') {
            count--;
            if (count === 0) enclosedcount++;
        } else if (!seen) {
            namecount++;
        }
    }
    return seen && (namecount > 0 || enclosedcount > 1) && count == 0;
}

function encloseParen(text) {
    var s = text.trim();
    if (isParenEnclosed(s) === false) {
        if (s.substr(0, 1) !== '(') s = '(' + s;
        if (s.substr(-1, 1) !== ')') s = s + ')';
        return s;
    } else {
        return text;
    }
}

function isParenEnclosed(name) {
    if (typeof name !== 'string') return false;
    name = name.trim();
    var hasEndParens = name.substr(-1, 1) === ')' ||
                       name.substr(-2, 2) === ');';
    if (!hasEndParens || name.substr(0, 1) !== '(') return false;
    var count = 1, quote = null;
    for (var ch, i = 1; i < name.length; i++) {
        ch = name[i];
        if (ch === '"' || ch === "'") {
            if (quote === ch) quote = null;
            else if (quote === null) quote = ch;
        }
        else if (quote !== null) {
                ;
        }
        else if (ch === '(') {
            count++;
        } else if (ch === ')') {
            count--;
        }
        if (i < (name.length - 1) && count === 0) {
            return false;
        }
    }
    return true;
}

function unparen(text) {
    if (typeof text !== 'string') return text;
    var s = text.trim();
    return isParenEnclosed(s) ? s.substr(1, s.length - 2) : text;
}

function semicolon(text) {
    return text && text.length ? (text[text.length - 1] === ';' ? '' : ';') : ';';
}

var forloopLetters = "ijkxzy";
var max_for_nidif = forloopLetters.length;
